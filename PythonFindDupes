import os
import hashlib
import zipfile
from io import BytesIO

CHUNK = 1024 * 1024  # 1 MB chunks

def hash_stream(stream):
    h = hashlib.sha256()
    while True:
        chunk = stream.read(CHUNK)
        if not chunk:
            break
        h.update(chunk)
    return h.hexdigest()

def is_zip_stream(stream):
    """Check if a file-like object is a ZIP by reading only the header."""
    start = stream.read(4)
    stream.seek(0)
    return start == b'PK\x03\x04'

def process_zip_stream(zstream, parent_label, hashes):
    with zipfile.ZipFile(zstream) as z:
        for member in z.infolist():
            if member.is_dir():
                continue

            label = f"{parent_label} :: {member.filename}"

            # Detect encrypted ZIP entry
            is_encrypted = member.flag_bits & 0x1
            if is_encrypted:
                key = f"ENCRYPTED::{member.filename}"
                hashes.setdefault(key, []).append(label)
                continue

            # Open member as a stream
            with z.open(member, "r") as mstream:
                # Check if this member is itself a ZIP
                header = mstream.read(4)
                mstream.seek(0)

                if header == b'PK\x03\x04':
                    # Nested ZIP — read it in chunks into a BytesIO buffer
                    # but without loading the whole file at once
                    nested = BytesIO()
                    while True:
                        chunk = mstream.read(CHUNK)
                        if not chunk:
                            break
                        nested.write(chunk)
                    nested.seek(0)
                    process_zip_stream(nested, label, hashes)
                else:
                    # Normal file — hash by streaming
                    h = hash_stream(mstream)
                    hashes.setdefault(h, []).append(label)

def scan_path(path, hashes):
    if zipfile.is_zipfile(path):
        with open(path, "rb") as f:
            process_zip_stream(f, path, hashes)
        return

    # Normal file on disk
    with open(path, "rb") as f:
        h = hash_stream(f)
    hashes.setdefault(h, []).append(path)

def scan_folder(root):
    hashes = {}
    for dirpath, _, filenames in os.walk(root):
        for name in filenames:
            full = os.path.join(dirpath, name)
            scan_path(full, hashes)
    return hashes

def report_duplicates(hashes):
    for h, files in hashes.items():
        if len(files) > 1:
            print("\nDuplicate group:")
            for f in files:
                print("  ", f)

if __name__ == "__main__":
    root_folder = r"/path/to/scan"
    hashes = scan_folder(root_folder)
    report_duplicates(hashes)
